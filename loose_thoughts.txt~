
~Current 08/17/18
	Spent some time thinking about lurd points. I kind of conceptualised it as a cross around the letter itself. Then I realized, I could do a whole square for every letter surrounding the current letter. THEN I REALIZED - I could have the array point to the diagonal points instead of a whole square. But... now thinking about I would probably still want the 'square' design, because I realized that the diagonals would be be any ascending/descending coud mean any direction



Things to finish: Fix your puzzle solver tests
Get lurd to have all points
Write searching functions - 
			Note: In the morning I was thinking of doing this to be on a current letter, and then using a search function would check (left/right) for horizontal, and return TRUE or FALSE depending. But the output is just supposed to be correct values. Also I keep thinking that the user doesn't actually do anything for the program. You give a puzzle and get the result, it's not acutally interactive. 


Well I didn't plan on manipulating @@mapped_puzzle. I originally wanted to manipulate points_list because it was the relevant stuff, but I ran through my variables that were already variations of @@mapped_puzzle and a lot weren't returning quite what I expected. So I just went with mapped_puzzle. 

Can move onto the actual search functions. Will want to look into the poorly expecting variables. 





LURD - l, u, r, d lu, ru, ld, rd
		,[(x_axis-1),((y_axis-1)],[(x_axis-1),(y_axis+1)],[(x_axis+1),(y_axis+1)],[(x_axis+1),(y_axis-1)]



~ Starting Project

        Ease of building the project and running tests
        Project organization and ease of understanding
        Naming conventions and clarity
        Clean code (as defined by the book of the same name) at the module/class
							and function/method level
        Minimal duplication (DRY)
        Idiomatic use of the programming language and associated tools
        Originality of solution (it must not be plagiarized)



	If you need TDD resources, I wanted to make sure to give you some links/books to help you along in this process.

	1. http://codemanship.co.uk/pa rlezuml/blog/?postid=1533

	2. Kent Beck. Test Driven Development: By Example. Addison-Wesley, Reading, MA, 2002

	3. Kent Beck. Extreme Programming Explained: Embrace Change. Addison- Wesley

	Longman, Reading, MA, 2000

	4. James Grenning. Test-Driven Development for Embedded C, The Pragmatic

	Programmers

	5. http://geepawhill.org/five- underplayed- Premises-of- tdd-2/



1. make build / read me


input:

text file
first line is always the string of terms.
every line is a list of single characters, A-Z <-- case sensitivity


output: the words and location of each letter



Rules:
Grid is always square, so rows has to equal columns
Words may be located horizontally, vertically, diagonally, and both forwards and backwards.
Words will never "wrap" around the edges of the grid.




User stories

As the Puzzle Solver
I want to search horizontally
So that I can find words on the X axis

As the Puzzle Solver
I want to search vertically
So that I can find words on the Y axis

As the Puzzle Solver
I want to search diagonally descending
So that I can find words the descend along the X axis

As the Puzzle Solver
I want to search diagonally ascending
So that I can find words that ascend along the X axis

As the Puzzle Solver
I want to search backwards
So that I can find words in reverse along all axes


Initial thoughts:

Functions to search
delimiter is a comma
hash for letter locations


notes on tdd from sources:
	a file per test/class per test
	descriptive name for test functions


Quick google for ruby and testing:
	This means don't write any non-testing code unless you have a failing test.
 	Write a test before you write the code
    	Make sure the test fails! It's important to know you're testing logic is correct
    	Before writing the next test make sure all tests succeed
    	You can always clean up your code, if the tests keep working you didn't change the design



assert (output, input)

	write test
	then class for test
	then run test so that it will fail, and then write code for it pass
	commit for every test




Organization of their code:
.idea
out -dir
src -dir
test - dir

iml




Not quite the solution: but thinking how I could build the puzzle

make row: random characters for x width, separate by comma
make column: random characters for y length
amount - squared
so enter a number - so 7 would be 7 down, 7 across
		 createRow() z many times

		&&
		create hash size of 7^2 and the hash has values (x location, y location)
add a word -

word object
puzzle object


reject puzzle if its not a square

classes?



puzzle -
	has the rules for the grid;
	can also create the actual puzzle

puzzle_solver
	has functions to search




I imagine I can have a arrays or hashes for cooridinates?

2d array - represent locations for cooridinates

hash table


x-axis,y-axis,letter,word
0,0,R,(Boolean)













